{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\ADMIN\\\\Desktop\\\\Flight Searcher\\\\React-flight-booking\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport flightData from './../data.json';\nimport { transformFlightDates } from './utils';\n\n//Using a graph algorithm to recursively explore all the connected nodes and find all connected flight paths\nfunction paths({\n  graph = [],\n  from,\n  to,\n  date\n}, path = []) {\n  const linkedNodes = connectedNodes(nodes.bind(null, graph));\n  return explore(from, to);\n  function explore(currNode, to, paths = [], originalNode) {\n    path.push(originalNode || currNode);\n    for (let linkedNode of linkedNodes(currNode)) {\n      if (linkedNode.destination === to) {\n        let result = path.slice(); // copy values\n        result.push(_objectSpread({}, linkedNode));\n        paths.push(result);\n        continue;\n      }\n      // do not traverse paths already explored\n      if (!hasEdgeBeenTraversedInPath({\n        edge: {\n          from: currNode,\n          to: linkedNode.destination\n        },\n        path: path.map(a => a && a.destination ? a.destination : a)\n      })) {\n        explore(linkedNode.destination, to, paths, linkedNode);\n      }\n    }\n    path.pop(); // sub-graph fully explored \n\n    return paths;\n  }\n}\n\n/** \r\n* Get all nodes linked \r\n* to from `node`.\r\n*/\nfunction nodes(graph, node) {\n  const list = graph.reduce((p, c) => {\n    c.origin === node && p.push({\n      destination: c.destination,\n      config: _objectSpread({}, c)\n    });\n    return p;\n  }, []);\n  return list;\n}\n\n/**\r\n* Has an edge been followed \r\n* in the given path?\r\n*/\nfunction hasEdgeBeenTraversedInPath({\n  edge,\n  path\n}) {\n  var indices = allIndices(path, edge.from);\n  return indices.some(i => path[i + 1] === edge.to);\n}\n\n/**\r\n* Utility to get all indices of \r\n* values matching `val` in `arr`.\r\n*/\nfunction allIndices(arr, value) {\n  var indices = [],\n    i;\n  for (i = 0; i < arr.length; i++) {\n    if (arr[i] === value) {\n      indices.push(i);\n    }\n  }\n  return indices;\n}\n\n/**\r\n* Avoids recalculating flight route \r\n* nodes.\r\n*/\nfunction connectedNodes(fn) {\n  const flightCache = new Map();\n  return function () {\n    var key = JSON.stringify(arguments);\n    var cached = flightCache.get(key);\n    if (cached) {\n      return cached;\n    }\n    cached = fn.apply(this, arguments);\n    flightCache.set(key, cached);\n    return cached;\n  };\n}\nfunction filterPaths(paths, date, numOfPassengers) {\n  const list = paths.filter(path => {\n    return isSameDestination(path);\n  });\n  const finalPaths = list.filter(path => {\n    return checkLayoverCriteria(path, date);\n  });\n  const transformedPaths = {\n    nonStopFlights: [],\n    multiStopFlights: []\n  };\n  finalPaths.forEach((path, index) => {\n    if (path.length === 2) {\n      transformedPaths.nonStopFlights.push(_objectSpread({}, path[1].config, {\n        price: path[1].config.price * (parseInt(numOfPassengers) || 1)\n      }));\n    } else {\n      let totalFare = 0,\n        multiFlights = [],\n        layovers = path.length - 1;\n      for (let i = 1; i < path.length; i++) {\n        multiFlights.push(_objectSpread({}, path[i].config));\n        totalFare += path[i].config.price;\n      }\n      transformedPaths.multiStopFlights.push({\n        cumulativeFlight: {\n          origin: path[0],\n          destination: path[layovers].destination,\n          date: path[1].config.date,\n          departureTime: path[1].config.departureTime,\n          arrivalTime: path[layovers].config.arrivalTime,\n          arrivalTimeStamp: path[layovers].config.arrivalTimeStamp,\n          departureTimeStamp: path[1].config.departureTimeStamp,\n          dayChange: path[1].config.date !== path[layovers].config.date,\n          totalFare: totalFare * (parseInt(numOfPassengers) || 1)\n        },\n        flights: multiFlights\n      });\n    }\n    return transformedPaths;\n  });\n  return transformedPaths;\n}\nfunction checkLayoverCriteria(path, startDate) {\n  let lowerLayover = false;\n  if (path.length > 1 && path[1].config.date !== startDate.replace(/-/g, '/')) {\n    return false;\n  }\n  for (let i = 0; i < path.length - 1; i++) {\n    if (typeof path[i] === \"object\" && typeof path[i + 1] === \"object\" && path[i + 1].config.departureTimeStamp - path[i].config.arrivalTimeStamp <= 1800000) {\n      lowerLayover = true;\n      break;\n    }\n  }\n  return !lowerLayover;\n}\nfunction isSameDestination(links) {\n  let duplicate = false;\n  let keys = {};\n  for (let i = 0; i < links.length; i++) {\n    const keyName = links[i] && links[i].destination ? links[i].destination : links[i];\n    if (keys.hasOwnProperty(keyName)) {\n      duplicate = true;\n      break;\n    }\n    keys[keyName] = links[i];\n  }\n  return !duplicate;\n}\nexport function findPaths({\n  flights = transformFlightDates(flightData),\n  criteria = {\n    origin: 'Bengaluru (BLR)',\n    destination: 'Delhi (DEL)'\n  }\n}) {\n  return filterPaths(paths({\n    graph: flights,\n    from: criteria.origin,\n    to: criteria.destination\n  }), criteria.date, criteria.numOfPassengers);\n}","map":{"version":3,"names":["flightData","transformFlightDates","paths","graph","from","to","date","path","linkedNodes","connectedNodes","nodes","bind","explore","currNode","originalNode","push","linkedNode","destination","result","slice","hasEdgeBeenTraversedInPath","edge","map","a","pop","node","list","reduce","p","c","origin","config","indices","allIndices","some","i","arr","value","length","fn","flightCache","Map","key","JSON","stringify","arguments","cached","get","apply","set","filterPaths","numOfPassengers","filter","isSameDestination","finalPaths","checkLayoverCriteria","transformedPaths","nonStopFlights","multiStopFlights","forEach","index","price","parseInt","totalFare","multiFlights","layovers","cumulativeFlight","departureTime","arrivalTime","arrivalTimeStamp","departureTimeStamp","dayChange","flights","startDate","lowerLayover","replace","links","duplicate","keys","keyName","hasOwnProperty","findPaths","criteria"],"sources":["C:/Users/ADMIN/Desktop/Flight Searcher/React-flight-booking/src/lib/flightManager.js"],"sourcesContent":["import flightData from './../data.json';\r\nimport { transformFlightDates } from './utils';\r\n\r\n//Using a graph algorithm to recursively explore all the connected nodes and find all connected flight paths\r\nfunction paths({ graph = [], from, to, date }, path = []) {\r\n  const linkedNodes = connectedNodes(nodes.bind(null, graph));\r\n  return explore(from, to);\r\n\r\n  function explore(currNode, to, paths = [], originalNode) {\r\n    path.push(originalNode || currNode);\r\n    for (let linkedNode of linkedNodes(currNode)) {\r\n      if (linkedNode.destination === to) {\r\n        let result = path.slice(); // copy values\r\n        result.push({ ...linkedNode });\r\n        paths.push(result);\r\n        continue;\r\n      }\r\n      // do not traverse paths already explored\r\n      if (!hasEdgeBeenTraversedInPath({\r\n        edge: {\r\n          from: currNode,\r\n          to: linkedNode.destination\r\n        },\r\n        path: path.map(a => a && a.destination ? a.destination : a)\r\n      })) {\r\n        explore(linkedNode.destination, to, paths, linkedNode);\r\n      }\r\n    }\r\n    path.pop(); // sub-graph fully explored \r\n\r\n    return paths;\r\n  }\r\n}\r\n\r\n/** \r\n* Get all nodes linked \r\n* to from `node`.\r\n*/\r\nfunction nodes(graph, node) {\r\n  const list = graph.reduce((p, c) => {\r\n    (c.origin === node) && p.push({ destination: c.destination, config: { ...c } });\r\n    return p;\r\n  }, []);\r\n  return list;\r\n}\r\n\r\n/**\r\n* Has an edge been followed \r\n* in the given path?\r\n*/\r\nfunction hasEdgeBeenTraversedInPath({ edge, path }) {\r\n  var indices = allIndices(path, edge.from);\r\n  return indices.some(i => path[i + 1] === edge.to);\r\n}\r\n\r\n/**\r\n* Utility to get all indices of \r\n* values matching `val` in `arr`.\r\n*/\r\nfunction allIndices(arr, value) {\r\n  var indices = [],\r\n    i;\r\n  for (i = 0; i < arr.length; i++) {\r\n    if (arr[i] === value) {\r\n      indices.push(i);\r\n    }\r\n  }\r\n  return indices;\r\n}\r\n\r\n/**\r\n* Avoids recalculating flight route \r\n* nodes.\r\n*/\r\nfunction connectedNodes(fn) {\r\n  const flightCache = new Map();\r\n  return function () {\r\n    var key = JSON.stringify(arguments);\r\n    var cached = flightCache.get(key);\r\n    if (cached) {\r\n      return cached;\r\n    }\r\n    cached = fn.apply(this, arguments)\r\n    flightCache.set(key, cached);\r\n    return cached;\r\n  };\r\n}\r\n\r\nfunction filterPaths(paths, date, numOfPassengers) {\r\n\r\n  const list = paths.filter(path => {\r\n    return isSameDestination(path);\r\n  });\r\n\r\n  const finalPaths = list.filter(path => {\r\n    return checkLayoverCriteria(path, date);\r\n  });\r\n\r\n  const transformedPaths = {\r\n    nonStopFlights: [],\r\n    multiStopFlights: [],\r\n  }\r\n\r\n  finalPaths.forEach((path, index) => {\r\n    if (path.length === 2) {\r\n      transformedPaths.nonStopFlights.push({\r\n        ...path[1].config,\r\n        price: path[1].config.price * (parseInt(numOfPassengers) || 1)\r\n      })\r\n    }\r\n    else {\r\n      let totalFare = 0, multiFlights = [], layovers = path.length - 1;\r\n      for (let i = 1; i < path.length; i++) {\r\n        multiFlights.push({ ...path[i].config });\r\n        totalFare += path[i].config.price;\r\n      }\r\n\r\n      transformedPaths.multiStopFlights.push({\r\n        cumulativeFlight: {\r\n          origin: path[0],\r\n          destination: path[layovers].destination,\r\n          date: path[1].config.date,\r\n          departureTime: path[1].config.departureTime,\r\n          arrivalTime: path[layovers].config.arrivalTime,\r\n          arrivalTimeStamp: path[layovers].config.arrivalTimeStamp,\r\n          departureTimeStamp: path[1].config.departureTimeStamp,\r\n          dayChange: path[1].config.date !== path[layovers].config.date,\r\n          totalFare: totalFare * (parseInt(numOfPassengers) || 1)\r\n        },\r\n        flights: multiFlights\r\n      })\r\n    }\r\n\r\n    return transformedPaths;\r\n  });\r\n\r\n  return transformedPaths;\r\n}\r\n\r\nfunction checkLayoverCriteria(path, startDate) {\r\n  let lowerLayover = false;\r\n\r\n  if (path.length > 1 && (path[1].config.date !== startDate.replace(/-/g, '/'))) {\r\n    return false;\r\n  }\r\n\r\n  for (let i = 0; i < path.length - 1; i++) {\r\n    if (typeof path[i] === \"object\" && typeof path[i + 1] === \"object\" && path[i + 1].config.departureTimeStamp - path[i].config.arrivalTimeStamp <= 1800000) {\r\n      lowerLayover = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return !lowerLayover;\r\n}\r\n\r\nfunction isSameDestination(links) {\r\n  let duplicate = false;\r\n  let keys = {};\r\n  for (let i = 0; i < links.length; i++) {\r\n    const keyName = links[i] && links[i].destination ? links[i].destination : links[i];\r\n    if (keys.hasOwnProperty(keyName)) {\r\n      duplicate = true;\r\n      break;\r\n    }\r\n    keys[keyName] = links[i]\r\n  }\r\n  return !duplicate;\r\n}\r\n\r\nexport function findPaths({ flights = transformFlightDates(flightData), criteria = { origin: 'Bengaluru (BLR)', destination: 'Delhi (DEL)' } }) {\r\n  return filterPaths(paths({\r\n    graph: flights,\r\n    from: criteria.origin,\r\n    to: criteria.destination,\r\n  }), criteria.date, criteria.numOfPassengers)\r\n}\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}